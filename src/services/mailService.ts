import { supabase } from "@/integrations/supabase/client";
import { Document, DocumentAttachment, DocumentDestination, DocumentFilters, DocumentStatus, DocumentType, Template, TemplateField } from "@/types/mail";

// Document types
export async function getDocumentTypes() {
  const { data, error } = await supabase
    .from("mail_document_types")
    .select("*")
    .order("name");
  
  if (error) {
    console.error("Error fetching document types:", error);
    throw error;
  }
  
  return data as DocumentType[];
}

// Documents
export async function getDocuments(filters?: DocumentFilters) {
  let query = supabase
    .from("mail_documents")
    .select(`
      *,
      document_type:document_type_id(*)
    `);
  
  // Apply filters if provided
  if (filters) {
    if (filters.type) {
      query = query.eq("document_type_id", filters.type);
    }
    
    if (filters.department) {
      query = query.eq("department", filters.department);
    }
    
    if (filters.status) {
      query = query.eq("status", filters.status);
    }
    
    if (filters.dateRange) {
      query = query.gte("created_at", filters.dateRange.from.toISOString());
      query = query.lte("created_at", filters.dateRange.to.toISOString());
    }
    
    if (filters.search) {
      query = query.or(`title.ilike.%${filters.search}%,protocol_number.ilike.%${filters.search}%`);
    }
  }
  
  const { data, error } = await query.order("created_at", { ascending: false });
  
  if (error) {
    console.error("Error fetching documents:", error);
    throw error;
  }
  
  return data as Document[];
}

export async function getDocument(id: string) {
  const { data, error } = await supabase
    .from("mail_documents")
    .select(`
      *,
      document_type:document_type_id(*)
    `)
    .eq("id", id)
    .single();
  
  if (error) {
    console.error("Error fetching document:", error);
    throw error;
  }
  
  return data as Document;
}

export async function createDocument(document: Partial<Document>) {
  const { data, error } = await supabase
    .from("mail_documents")
    .insert({
      title: document.title,
      content: document.content,
      document_type_id: document.document_type_id,
      creator_id: document.creator_id,
      department: document.department,
      template_id: document.template_id || null,
      // protocol_number will be generated by trigger
      status: document.status || "pending"
    })
    .select()
    .single();
  
  if (error) {
    console.error("Error creating document:", error);
    throw error;
  }
  
  return data as Document;
}

export async function updateDocumentStatus(id: string, status: DocumentStatus) {
  const { data, error } = await supabase
    .from("mail_documents")
    .update({ status })
    .eq("id", id)
    .select()
    .single();
  
  if (error) {
    console.error("Error updating document status:", error);
    throw error;
  }
  
  return data as Document;
}

// Document destinations
export async function getDocumentDestinations(documentId: string) {
  const { data, error } = await supabase
    .from("mail_document_destinations")
    .select("*")
    .eq("document_id", documentId)
    .order("sent_at", { ascending: false });
  
  if (error) {
    console.error("Error fetching document destinations:", error);
    throw error;
  }
  
  return data as DocumentDestination[];
}

export async function getIncomingDocuments(department: string) {
  const { data, error } = await supabase
    .from("mail_document_destinations")
    .select(`
      *,
      document:document_id(*, document_type:document_type_id(*))
    `)
    .eq("to_department", department)
    .order("sent_at", { ascending: false });
  
  if (error) {
    console.error("Error fetching incoming documents:", error);
    throw error;
  }
  
  return data as (DocumentDestination & {document: Document})[];
}

export async function getOutgoingDocuments(department: string) {
  const { data, error } = await supabase
    .from("mail_document_destinations")
    .select(`
      *,
      document:document_id(*, document_type:document_type_id(*))
    `)
    .eq("from_department", department)
    .order("sent_at", { ascending: false });
  
  if (error) {
    console.error("Error fetching outgoing documents:", error);
    throw error;
  }
  
  return data as (DocumentDestination & {document: Document})[];
}

export async function forwardDocument(documentId: string, fromDepartment: string, toDepartment: string, sentBy: string) {
  const { data, error } = await supabase
    .from("mail_document_destinations")
    .insert([
      {
        document_id: documentId,
        from_department: fromDepartment,
        to_department: toDepartment,
        sent_by: sentBy
      }
    ])
    .select()
    .single();
  
  if (error) {
    console.error("Error forwarding document:", error);
    throw error;
  }
  
  // Update document status
  await updateDocumentStatus(documentId, "forwarded");
  
  return data as DocumentDestination;
}

export async function markDocumentAsRead(destinationId: string) {
  const { data, error } = await supabase
    .from("mail_document_destinations")
    .update({ read_at: new Date().toISOString() })
    .eq("id", destinationId)
    .select()
    .single();
  
  if (error) {
    console.error("Error marking document as read:", error);
    throw error;
  }
  
  return data as DocumentDestination;
}

export async function respondToDocument(destinationId: string, response: string) {
  const { data, error } = await supabase
    .from("mail_document_destinations")
    .update({
      response_text: response,
      status: "responded",
      received_at: new Date().toISOString()
    })
    .eq("id", destinationId)
    .select()
    .single();
  
  if (error) {
    console.error("Error responding to document:", error);
    throw error;
  }
  
  return data as DocumentDestination;
}

export async function markDocumentAsCompleted(id: string) {
  const { data, error } = await supabase
    .from("mail_documents")
    .update({ status: "completed" })
    .eq("id", id)
    .select()
    .single();
  
  if (error) {
    console.error("Error marking document as completed:", error);
    throw error;
  }
  
  return data as Document;
}

// Document attachments
export async function getDocumentAttachments(documentId: string) {
  const { data, error } = await supabase
    .from("mail_document_attachments")
    .select("*")
    .eq("document_id", documentId)
    .order("uploaded_at", { ascending: false });
  
  if (error) {
    console.error("Error fetching document attachments:", error);
    throw error;
  }
  
  return data as DocumentAttachment[];
}

export async function uploadAttachment(file: File, documentId: string, userId: string) {
  // Upload file to storage
  const filePath = `${documentId}/${file.name}`;
  const { data: fileData, error: fileError } = await supabase
    .storage
    .from("mail_attachments")
    .upload(filePath, file);
  
  if (fileError) {
    console.error("Error uploading file:", fileError);
    throw fileError;
  }
  
  // Create attachment record
  const { data, error } = await supabase
    .from("mail_document_attachments")
    .insert([
      {
        document_id: documentId,
        file_name: file.name,
        file_path: filePath,
        file_type: file.type,
        file_size: file.size,
        uploaded_by: userId
      }
    ])
    .select()
    .single();
  
  if (error) {
    console.error("Error creating attachment record:", error);
    throw error;
  }
  
  return data as DocumentAttachment;
}

export async function getAttachmentUrl(filePath: string) {
  const { data, error } = await supabase
    .storage
    .from("mail_attachments")
    .createSignedUrl(filePath, 3600); // URL valid for 1 hour
  
  if (error) {
    console.error("Error getting attachment URL:", error);
    throw error;
  }
  
  return data.signedUrl;
}

// Templates
export async function getTemplates(departmentId?: string) {
  let query = supabase
    .from("mail_templates")
    .select(`
      *,
      document_type:document_type_id(*)
    `);
    
  if (departmentId) {
    query = query.contains("departments", [departmentId]);
  }
  
  const { data, error } = await query.eq("is_active", true).order("name");
  
  if (error) {
    console.error("Error fetching templates:", error);
    throw error;
  }
  
  return data as Template[];
}

export async function getTemplate(id: string) {
  const { data, error } = await supabase
    .from("mail_templates")
    .select(`
      *,
      document_type:document_type_id(*),
      fields:mail_template_fields(*)
    `)
    .eq("id", id)
    .single();
  
  if (error) {
    console.error("Error fetching template:", error);
    throw error;
  }
  
  return data as Template;
}

export async function createTemplate(template: Partial<Template>, fields: Partial<TemplateField>[]) {
  // Create template
  const { data, error } = await supabase
    .from("mail_templates")
    .insert([
      {
        name: template.name!,
        description: template.description || null,
        content: template.content!,
        document_type_id: template.document_type_id || null,
        creator_id: template.creator_id!,
        departments: template.departments!,
        is_active: true
      }
    ])
    .select()
    .single();
  
  if (error) {
    console.error("Error creating template:", error);
    throw error;
  }
  
  // Create template fields
  if (fields && fields.length > 0) {
    const fieldsToInsert = fields.map((field, index) => ({
      template_id: data.id,
      field_key: field.field_key!,
      field_label: field.field_label!,
      field_type: field.field_type!,
      field_options: field.field_options || null,
      is_required: field.is_required || false,
      order_position: field.order_position || index
    }));
    
    const { error: fieldsError } = await supabase
      .from("mail_template_fields")
      .insert(fieldsToInsert);
    
    if (fieldsError) {
      console.error("Error creating template fields:", fieldsError);
      throw fieldsError;
    }
  }
  
  return data as Template;
}

export async function updateTemplate(id: string, template: Partial<Template>, fields: Partial<TemplateField>[]) {
  // Update template
  const { data, error } = await supabase
    .from("mail_templates")
    .update({
      name: template.name,
      description: template.description,
      content: template.content,
      document_type_id: template.document_type_id,
      departments: template.departments,
      updated_at: new Date().toISOString()
    })
    .eq("id", id)
    .select()
    .single();
  
  if (error) {
    console.error("Error updating template:", error);
    throw error;
  }
  
  // Delete existing fields
  await supabase
    .from("mail_template_fields")
    .delete()
    .eq("template_id", id);
  
  // Create new template fields
  if (fields && fields.length > 0) {
    const fieldsToInsert = fields.map((field, index) => ({
      template_id: id,
      field_key: field.field_key!,
      field_label: field.field_label!,
      field_type: field.field_type!,
      field_options: field.field_options || null,
      is_required: field.is_required || false,
      order_position: field.order_position || index
    }));
    
    const { error: fieldsError } = await supabase
      .from("mail_template_fields")
      .insert(fieldsToInsert);
    
    if (fieldsError) {
      console.error("Error creating template fields:", fieldsError);
      throw fieldsError;
    }
  }
  
  return data as Template;
}

export async function deleteTemplate(id: string) {
  // Mark as inactive instead of deleting
  const { data, error } = await supabase
    .from("mail_templates")
    .update({ is_active: false })
    .eq("id", id)
    .select()
    .single();
  
  if (error) {
    console.error("Error deleting template:", error);
    throw error;
  }
  
  return data as Template;
}
