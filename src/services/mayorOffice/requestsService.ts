
import { supabase } from "@/integrations/supabase/client";
import {
  DirectRequest,
  RequestAttachment,
  RequestComment,
  RequestStatus,
  PriorityLevel,
} from "@/types/mayorOffice";
import { toast } from "@/hooks/use-toast";
import { uploadMayorOfficeFile } from "./storageService";

// Direct Requests
export async function getDirectRequests(
  status?: RequestStatus,
  department?: string,
  priority?: PriorityLevel
): Promise<DirectRequest[]> {
  try {
    let query = supabase
      .from("mayor_direct_requests")
      .select(
        `*, 
        mayor_request_attachments(*), 
        mayor_request_comments(*)`
      )
      .order("created_at", { ascending: false });

    if (status) {
      query = query.eq("status", status);
    }
    if (department) {
      query = query.eq("target_department", department);
    }
    if (priority) {
      query = query.eq("priority", priority);
    }

    const { data, error } = await query;

    if (error) throw error;

    return (data || []).map((request) => ({
      id: request.id,
      protocolNumber: request.protocol_number,
      title: request.title,
      description: request.description,
      requesterId: request.requester_id,
      targetDepartment: request.target_department,
      priority: request.priority as PriorityLevel,
      status: request.status as RequestStatus,
      dueDate: request.due_date ? new Date(request.due_date) : undefined,
      completedAt: request.completed_at
        ? new Date(request.completed_at)
        : undefined,
      createdAt: new Date(request.created_at),
      updatedAt: new Date(request.updated_at),
      attachments: request.mayor_request_attachments?.map((attachment: any) => ({
        id: attachment.id,
        requestId: attachment.request_id,
        fileName: attachment.file_name,
        filePath: attachment.file_path,
        fileType: attachment.file_type,
        fileSize: attachment.file_size,
        uploadedBy: attachment.uploaded_by,
        createdAt: new Date(attachment.created_at),
      })),
      comments: request.mayor_request_comments?.map((comment: any) => ({
        id: comment.id,
        requestId: comment.request_id,
        commentText: comment.comment_text,
        authorId: comment.author_id,
        createdAt: new Date(comment.created_at),
      })),
    }));
  } catch (error: any) {
    console.error("Error fetching direct requests:", error.message);
    toast({
      title: "Erro ao carregar solicitações",
      description: error.message,
      variant: "destructive",
    });
    return [];
  }
}

export async function createDirectRequest(request: Omit<DirectRequest, "id" | "protocolNumber" | "createdAt" | "updatedAt" | "attachments" | "comments">): Promise<DirectRequest | null> {
  try {
    // Note: protocol_number is generated by a database trigger
    const { data, error } = await supabase
      .from("mayor_direct_requests")
      .insert({
        title: request.title,
        description: request.description,
        requester_id: request.requesterId,
        target_department: request.targetDepartment,
        priority: request.priority,
        status: request.status,
        due_date: request.dueDate?.toISOString().split("T")[0],
      })
      .select()
      .single();

    if (error) throw error;

    if (!data) throw new Error("Falha ao criar solicitação");

    toast({
      title: "Solicitação criada",
      description: `Protocolo: ${data.protocol_number}`,
    });

    return {
      id: data.id,
      protocolNumber: data.protocol_number,
      title: data.title,
      description: data.description,
      requesterId: data.requester_id,
      targetDepartment: data.target_department,
      priority: data.priority as PriorityLevel,
      status: data.status as RequestStatus,
      dueDate: data.due_date ? new Date(data.due_date) : undefined,
      completedAt: data.completed_at ? new Date(data.completed_at) : undefined,
      createdAt: new Date(data.created_at),
      updatedAt: new Date(data.updated_at),
      attachments: [],
      comments: [],
    };
  } catch (error: any) {
    console.error("Error creating direct request:", error.message);
    toast({
      title: "Erro ao criar solicitação",
      description: error.message,
      variant: "destructive",
    });
    return null;
  }
}

export async function updateDirectRequest(
  id: string,
  requestData: Partial<DirectRequest>
): Promise<boolean> {
  try {
    const updateData: any = {};
    if (requestData.title) updateData.title = requestData.title;
    if (requestData.description) updateData.description = requestData.description;
    if (requestData.targetDepartment) updateData.target_department = requestData.targetDepartment;
    if (requestData.priority) updateData.priority = requestData.priority;
    if (requestData.status) updateData.status = requestData.status;
    if (requestData.dueDate) updateData.due_date = requestData.dueDate.toISOString().split("T")[0];
    
    if (requestData.status === "completed" && !requestData.completedAt) {
      updateData.completed_at = new Date().toISOString();
    }

    const { error } = await supabase
      .from("mayor_direct_requests")
      .update(updateData)
      .eq("id", id);

    if (error) throw error;

    toast({
      title: "Solicitação atualizada",
      description: "Os dados da solicitação foram atualizados com sucesso",
    });

    return true;
  } catch (error: any) {
    console.error("Error updating direct request:", error.message);
    toast({
      title: "Erro ao atualizar solicitação",
      description: error.message,
      variant: "destructive",
    });
    return false;
  }
}

// Add comment to a direct request
export async function addRequestComment(
  requestId: string,
  commentText: string,
  authorId: string
): Promise<RequestComment | null> {
  try {
    const { data, error } = await supabase
      .from("mayor_request_comments")
      .insert({
        request_id: requestId,
        comment_text: commentText,
        author_id: authorId,
      })
      .select()
      .single();

    if (error) throw error;

    toast({
      title: "Comentário adicionado",
      description: "Seu comentário foi adicionado com sucesso",
    });

    return {
      id: data.id,
      requestId: data.request_id,
      commentText: data.comment_text,
      authorId: data.author_id,
      createdAt: new Date(data.created_at),
    };
  } catch (error: any) {
    console.error("Error adding comment:", error.message);
    toast({
      title: "Erro ao adicionar comentário",
      description: error.message,
      variant: "destructive",
    });
    return null;
  }
}

// Add attachment to a direct request
export async function addRequestAttachment(
  requestId: string,
  file: File,
  userId: string
): Promise<RequestAttachment | null> {
  try {
    const filePath = await uploadMayorOfficeFile(file, "requests");
    if (!filePath) throw new Error("Failed to upload file");

    const { data, error } = await supabase
      .from("mayor_request_attachments")
      .insert({
        request_id: requestId,
        file_name: file.name,
        file_path: filePath,
        file_type: file.type,
        file_size: file.size,
        uploaded_by: userId,
      })
      .select()
      .single();

    if (error) throw error;

    toast({
      title: "Anexo adicionado",
      description: "Arquivo anexado com sucesso",
    });

    return {
      id: data.id,
      requestId: data.request_id,
      fileName: data.file_name,
      filePath: data.file_path,
      fileType: data.file_type,
      fileSize: data.file_size,
      uploadedBy: data.uploaded_by,
      createdAt: new Date(data.created_at),
    };
  } catch (error: any) {
    console.error("Error adding attachment:", error.message);
    toast({
      title: "Erro ao adicionar anexo",
      description: error.message,
      variant: "destructive",
    });
    return null;
  }
}
