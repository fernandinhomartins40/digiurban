
import { supabase } from "@/integrations/supabase/client";
import { DirectRequest, PriorityLevel, RequestStatus } from "@/types/mayorOffice";
import { toast } from "@/hooks/use-toast";

// Interface for creating a direct request
interface CreateDirectRequestDTO {
  title: string;
  description: string;
  requester_id: string;
  target_department: string;
  priority: PriorityLevel;
  status: RequestStatus;
  due_date?: string;
}

// Interface for updating a direct request
interface UpdateDirectRequestDTO {
  id: string;
  title?: string;
  description?: string;
  target_department?: string;
  priority?: PriorityLevel;
  status?: RequestStatus;
  due_date?: string;
}

export async function getDirectRequests(status?: RequestStatus, department?: string): Promise<DirectRequest[]> {
  try {
    let query = supabase
      .from("mayor_direct_requests")
      .select(
        `*, 
        mayor_request_attachments(*),
        mayor_request_comments(*)`
      );
    
    // Apply filters if provided
    if (status) {
      query = query.eq('status', status);
    }
    
    if (department) {
      query = query.eq('target_department', department);
    }
    
    const { data, error } = await query.order("created_at", { ascending: false });

    if (error) throw error;

    return (data || []).map((request) => ({
      id: request.id,
      protocolNumber: request.protocol_number,
      title: request.title,
      description: request.description,
      requesterId: request.requester_id,
      requesterName: request.requester_id, // This field doesn't exist in the DB, using requester_id as fallback
      targetDepartment: request.target_department,
      priority: request.priority as PriorityLevel,
      status: request.status as RequestStatus,
      dueDate: request.due_date ? new Date(request.due_date) : undefined,
      completedAt: request.completed_at ? new Date(request.completed_at) : undefined,
      createdAt: new Date(request.created_at),
      updatedAt: new Date(request.updated_at),
      attachments: request.mayor_request_attachments?.map((attachment: any) => ({
        id: attachment.id,
        requestId: attachment.request_id,
        fileName: attachment.file_name,
        filePath: attachment.file_path,
        fileType: attachment.file_type,
        fileSize: attachment.file_size,
        uploadedBy: attachment.uploaded_by,
        createdAt: new Date(attachment.created_at),
      })) || [],
      comments: request.mayor_request_comments?.map((comment: any) => ({
        id: comment.id,
        requestId: comment.request_id,
        commentText: comment.comment_text,
        authorId: comment.author_id,
        createdAt: new Date(comment.created_at),
      })) || [],
    }));
  } catch (error: any) {
    console.error("Error fetching direct requests:", error.message);
    toast({
      title: "Erro ao carregar solicitações",
      description: error.message,
      variant: "destructive",
    });
    return [];
  }
}

export async function createDirectRequest(request: CreateDirectRequestDTO): Promise<DirectRequest | null> {
  try {
    // The protocol_number is auto-generated by the database, so we don't need to include it
    const { data, error } = await supabase
      .from("mayor_direct_requests")
      .insert({
        title: request.title,
        description: request.description,
        requester_id: request.requester_id,
        target_department: request.target_department,
        priority: request.priority,
        status: request.status,
        due_date: request.due_date,
      })
      .select()
      .single();

    if (error) throw error;

    toast({
      title: "Solicitação criada",
      description: `Solicitação ${data.protocol_number} criada com sucesso!`,
    });

    return {
      id: data.id,
      protocolNumber: data.protocol_number,
      title: data.title,
      description: data.description,
      requesterId: data.requester_id,
      requesterName: data.requester_id, // This field doesn't exist in the DB
      targetDepartment: data.target_department,
      priority: data.priority as PriorityLevel,
      status: data.status as RequestStatus,
      dueDate: data.due_date ? new Date(data.due_date) : undefined,
      completedAt: data.completed_at ? new Date(data.completed_at) : undefined,
      createdAt: new Date(data.created_at),
      updatedAt: new Date(data.updated_at),
      attachments: [],
      comments: [],
    };
  } catch (error: any) {
    console.error("Error creating direct request:", error.message);
    toast({
      title: "Erro ao criar solicitação",
      description: error.message,
      variant: "destructive",
    });
    return null;
  }
}

export async function updateDirectRequest(requestId: string, updateData: Partial<UpdateDirectRequestDTO>): Promise<boolean> {
  try {
    const updateValues = {
      ...(updateData.title && { title: updateData.title }),
      ...(updateData.description && { description: updateData.description }),
      ...(updateData.target_department && { target_department: updateData.target_department }),
      ...(updateData.priority && { priority: updateData.priority }),
      ...(updateData.status && { status: updateData.status }),
      ...(updateData.due_date && { due_date: updateData.due_date }),
    };

    const { error } = await supabase
      .from("mayor_direct_requests")
      .update(updateValues)
      .eq("id", requestId);

    if (error) throw error;

    toast({
      title: "Solicitação atualizada",
      description: "Solicitação atualizada com sucesso!",
    });

    return true;
  } catch (error: any) {
    console.error("Error updating direct request:", error.message);
    toast({
      title: "Erro ao atualizar solicitação",
      description: error.message,
      variant: "destructive",
    });
    return false;
  }
}
